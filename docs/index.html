<header class="entry-header">
    <h1 class="entry-title">CDI-Unit user guide</h1>
</header><!-- .entry-header -->

<div class="entry-content">
    <ol>
        <li><a href="#quickstart">Quickstart</a></li>
        <li><a href="#annotations">CDI-Unit annotations</a></li>
        <li><a href="#example">Example unit test</a></li>
        <li><a href="#controllingEnvironment">Controlling the CDI environment</a></li>
        <li><a href="#mocks">Using mocks</a></li>
        <li><a href="#alternatives">Using alternatives</a></li>
        <li><a href="#scopes">Using scopes</a></li>
        <li><a href="#weldVersions">Using a specific version of Weld</a></li>
        <li><a href="#testNg">TestNG support</a></li>
        <li><a href="#ejb">EJB support</a></li>
        <li><a href="#deltaspike">Deltaspike support</a></li>
        <li><a href="#jaxRs">JaxRS support</a></li>
    </ol>
    <h3 id="quickstart">1. Quickstart</h3>
    <p>Testing your Java&nbsp;<a href="http://download.oracle.com/javaee/6/tutorial/doc/giwhb.html"
                                 onclick="__gaTracker('send', 'event', 'outbound-article', 'http://download.oracle.com/javaee/6/tutorial/doc/giwhb.html', 'CDI');">CDI</a>
        application with CDI-Unit couldn&#39;t be easier. Just specify <code>@RunWith(CdiRunner.class)</code> on your <a
                href="http://www.junit.org/"
                onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.junit.org/', 'JUnit4');">JUnit4</a>
        test class to enable injection directly into the test class.</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class) // Runs the test with CDI-Unit
class MyTest {
  @Inject
  Something something; // This will be injected before the tests are run!

  ...
}</pre>
    <h3 id="annotations">2. CDI-Unit Annotations</h3>
    <p>CDI Unit provides the discovery annotations that affect the classes available to the unit test:</p>
    <ul>
        <li><a href="#controllingEnvironment">@AdditionalClasses/@AdditionalPackages/@AdditionalClasspath</a> &#8211;
            Makes classes/extensions/interceptors available to the unit test if not discovered automatically.
        </li>
        <li><a href="#enablingAlternatives">@EnabledAlternatives</a> &#8211; Makes classes annotated <a
                href="http://download.oracle.com/javaee/6/api/javax/enterprise/inject/Alternative.html"
                onclick="__gaTracker('send', 'event', 'outbound-article', 'http://download.oracle.com/javaee/6/api/javax/enterprise/inject/Alternative.html', '@Alternative');">@Alternative</a>&nbsp;available
            to the unit test and also marks them as enabled.
        </li>
        <li><a href="#producingAlternatives">@ProducesAlternative</a> &#8211; Makes a <a
                href="http://download.oracle.com/javaee/6/api/javax/enterprise/inject/Produces.html"
                onclick="__gaTracker('send', 'event', 'outbound-article', 'http://download.oracle.com/javaee/6/api/javax/enterprise/inject/Produces.html', '@Produces');">@Produces</a>&nbsp;field
            or method produce an enabled @Alternative.&nbsp;
        </li>
    </ul>
    <p>In addition <a href="#scopes">scoping annotations</a> can be used to simulate scopes for method calls:</p>
    <ul>
        <li>@InRequestScope &#8211; Starts a&nbsp;request&nbsp;for the method call.&nbsp;</li>
        <li>@InSessonScope &#8211; Starts a session&nbsp;for the method call.</li>
        <li>@InConversationScope &#8211; Starts converation for the method call.</li>
    </ul>
    <h3 id="example">3. Example unit test</h3>
    <p>Suppose you have a class&nbsp;<span class="s1">Starship</span>&nbsp;that injects&nbsp;<span
            class="s1">WarpDrive</span> that implements <span class="s1">Engine</span>:</p>
    <pre class="brush: java; title: ; notranslate" title="">class Starship { // We want to test this!

  @Inject
  WarpDrive engine;

  void start() {
    engine.start();
  }
}

interface Engine {

  void start();

}

class WarpDrive implements Engine {
  ...
}</pre>
    <p>You can test Starship and WarpDrive together:</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
class TestStarship {

  @Inject
  Starship starship;

  @Test
  public void testStart() {
    starship.start(); // Going to warp!
  }
}</pre>
    <p>WarpDrive will be injected into the Starship which will then be injected in to your unit test.</p>
    <h3 id="controllingEnvironment">4. Controlling the CDI environment</h3>
    <p>CDI-Unit will try to discover what classes should be available to the CDI environment automatically, but
        sometimes this is not possible. In this scenario we can use the
        @AdditionalClasses/@AdditionalPackages/@AdditionalClasspath annotations</p>
    <p>Suppose that we change the Starship example to inject an Engine rather than a WarpDrive:</p>
    <pre class="brush: java; title: ; notranslate" title="">class Starship {

  @Inject
  Engine engine; //We don't know the exact engine that this ship will have.

  void start() {
    engine.start();
  }
}</pre>
    <p>Running our test without modification will result in failure because there are no references to WarpDrive in the
        test or any of the injected fields.</p>
    <p>To fix this we have to tell CDI-Unit to explicitly add a class to the CDI environment:</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
@AdditionalClasses(WarpDrive.class) // WarpDrive is available to use.
class TestStarship {

  @Inject
  Starship starship;

  @Test
  public void testStart() {
    starship.start(); // Going to warp!
  }
}</pre>
    <p>CDI will automatically search for an implementation of Engine when trying to create a Starship instance.
        WarpDrive is available so it will be injected.</p>
    <h4>Discovery annotations</h4>
    <ul>
        <li>@AdditionalClasses &#8211; Explicitly add class(s) to the deployment</li>
        <li>@AdditionalPackages &#8211; Classes in the same package will all be added to the deployment</li>
        <li>@AdditionalClasspath &#8211; Classes in the same classpath entry location will be added to the deployment
        </li>
    </ul>
    <p>To make it easy to figure out what is in the CDI environment CDI-Unit prints all of the classes added to the
        environment at DEBUG log level during startup.</p>
    <h3 id="mocks">5. Using mocks</h3>
    <p>To test classes in isolation we shouldn&#39;t be using their dependencies. Instead we should be using a <a
            href="http://en.wikipedia.org/wiki/Mock_object"
            onclick="__gaTracker('send', 'event', 'outbound-article', 'http://en.wikipedia.org/wiki/Mock_object', 'mock');">mock</a>.&nbsp;There
        are many mocking libraries out there, however CDI-Unit has extra support for&nbsp;<a
                href="http://code.google.com/p/mockito/"
                onclick="__gaTracker('send', 'event', 'outbound-article', 'http://code.google.com/p/mockito/', 'Mockito');">Mockito</a>&nbsp;<a
                href="http://docs.mockito.googlecode.com/hg/latest/index.html?org/mockito/Mockito.html"
                onclick="__gaTracker('send', 'event', 'outbound-article', 'http://docs.mockito.googlecode.com/hg/latest/index.html?org/mockito/Mockito.html', '@Mock');">@Mock</a>
        annotations and &nbsp;<a href="http://easymock.org/"
                                 onclick="__gaTracker('send', 'event', 'outbound-article', 'http://easymock.org/', 'EasyMock');">EasyMock</a>&nbsp;<a
                href="http://easymock.org/EasyMock3_2_Documentation.html"
                onclick="__gaTracker('send', 'event', 'outbound-article', 'http://easymock.org/EasyMock3_2_Documentation.html', '@Mock');">@Mock</a>
        annotations </p>
    <p>Modifying the <a href="#example">StarshipTest</a> we can use the <a
            href="http://download.oracle.com/javaee/6/api/javax/enterprise/inject/Produces.html"
            onclick="__gaTracker('send', 'event', 'outbound-article', 'http://download.oracle.com/javaee/6/api/javax/enterprise/inject/Produces.html', '@Produces');">@Produces</a>
        annotation to make our mock available to the classes being tested.&nbsp;</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
//@AdditionalClasses(WarpDrive.class) WarpDrive is no longer required.
class TestStarship {

  @Inject
  Starship starship;

  @Produces
  @Mock // Mockito will create a mock for us.
  Engine engine;

  @Test
  public void testStart() {
    starship.start();

    // Verify that the mocks start method is called at least once.
    Mockito.verify(engine, Mockito.atLeastOnce()).start();
  }
}</pre>
    <p>That&#39;s it! Starship will be injected with our mock engine which we then verify the interaction with.</p>
    <h3 id="alternatives">6. Using alternatives</h3>
    <p>CDI is all about automatic configuration, but sometimes you need to give a hint as to which implementation to
        use. This is usually done via beans.xml, but in CDI-Unit we specify alternatives using annotations.</p>
    <p>Imagine you have an alternative implementation of Engine that you want to inject in your unit test.</p>
    <pre class="brush: java; title: ; notranslate" title="">@Alternative
class TranswarpDrive implements Engine {
  ...
}
</pre>
    <p>The TranswarpDrive class would normally need to be enabled via beans.xml.</p>
    <p id="enablingAlternatives"><strong>Enabling alternative classes:</strong></p>
    <p>The @ActivatedAlternatives annotaton like @AdditionalClasses will allow discovery of a class for testing, however
        it also&nbsp;<a href="http://docs.jboss.org/weld/reference/1.1.0.Final/en-US/html_single/#alternatives"
                        onclick="__gaTracker('send', 'event', 'outbound-article', 'http://docs.jboss.org/weld/reference/1.1.0.Final/en-US/html_single/#alternatives', 'enables the alternative');">enables
            the alternative</a>.</p>
    <p>The&nbsp;<a href="#example">StarshipTest</a>&nbsp;can be modified to use the new type of engine.</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
@ActivatedAlternatives(TranswarpDrive.class) // Enable this class to participate in discovery
                                               // and enable it.
class TestStarship {

  @Inject
  Starship starship;

  @Test
  public void testStart() {
    starship.start(); // Transwarp activated!
  }
}</pre>
    <p id="producingAlternatives"><strong>Producing alternatives:</strong></p>
    <p>Sometimes you want to create an alternative at runtime. The @ProducesAlternative annotation marks the
        class/field/method as an alternative therefore overridding any other implementation that is found during the
        discovery process.&nbsp;</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
@AdditionalClasses(WarpDrive.class) // Normally this implementation would be used
                                  // as long as there are no alternatives activated...
class TestStarship {

  @Inject Starship starship;

  @Produces
  @ProducesAlternative // This mock will be used instead!
  @Mock
  Engine engine;

  @Test
  public void testStart() {
    starship.start();
  }
}</pre>
    <h3 id="scopes">7. Using scopes</h3>
    <p>CDI-Unit has built in support for Request, Session and Conversation scopes using @InRequestScope, @InSessionScope
        and @InConversationScope.</p>
    <p><strong>Running a test within a scope using annotations:</strong></p>
    <pre class="brush: java; title: ; notranslate" title="">
class Starship {

  @Inject
  Provider&lt;engine&gt; engine; //If engine is at request scope then it must be accessed by provider.

  void start() {
    engine.get().start();
  }
}

@RequestScoped // This object will only be available from within a request
class RequestScopedWarpDrive implements Engine {
  ...
}

</pre>
    <p>In this case @InRequestScope is used to run the test from within the context of a request</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
//Provide implementation of HttpRequest
@AdditionalClasses({RequestScopedWarpDrive.class})
class TestStarship {

  @Inject
  Starship starship;

  @Test
  @InRequestScope //This test will be run within the context of a request
  public void testStart() {
    starship.start();
  }
}</pre>
    <p>CDI-Unit provides Http* classes copied from the Mockrunner project.</p>
    <p><strong>Explicitly controlling active scopes:</strong></p>
    <p>If you are testing code that runs over several requests then you may want to explicitly control activation and
        deactivation of scopes. Use ContextController to do this.</p>
    <pre class="brush: java; title: ; notranslate" title="">@RunWith(CdiRunner.class)
@AdditionalClasses(RequestScopedWarpDrive.class)
class TestStarship {

  @Inject
  ContextController contextController; //Obtain an instance of the context controller.

  @Inject
  Starship starship;

  @Test
  public void testStart() {
    contextController.openRequest(); //Start a new request
    starship.start();
    contextController.closeRequest(); //Close the current request.
  }
}</pre>
    <p>ContextController has methods to control Request and Session scopes.</p>
    <p>Note that if you close a session while a request is active then it will not be closed until the request is also
        closed.</p>
    <h3 id="weldVersions">8. Using a specific version of Weld</h3>
    <p>CDI-Unit will automatically use the version of Weld that was available when it was released. However in your
        project you may want to use a specific version. To achieve this simply exclude the weld dependency that from
        CDI-Unit and include the version you want in your pom. For example:</p>
    <pre class="brush: xml; title: ; notranslate" title="">
&lt;dependency&gt;
  &lt;groupId&gt;org.jglue.cdi-unit&lt;/groupId&gt;
  &lt;artifactId&gt;cdi-unit&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt;
      &lt;artifactId&gt;weld-se-core&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt;
  &lt;artifactId&gt;weld-se-core&lt;/artifactId&gt;
  &lt;version&gt;&lt;!--Your weld version--&gt;&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>
    <h3 id="testNg">9. TestNg support</h3>
    <p>A base class NgCdiRunner can be used to add CDI-Unit to your TestNG tests. For example:</p>
    <pre class="brush: java; title: ; notranslate" title="">
@ActivatedAlternatives(TranswarpDrive.class)
class TestStarship extends NgCdiRunner { //Extending NgCdiRunner adds CDI-Unit functionality

  @Inject
  Starship starship;

  @Test
  public void testStart() {
    starship.start(); // Transwarp activated!
  }
}</pre>
    <h3 id="ejb">10. Ejb support</h3>
    <p>Once a test class is annotated with @SupportEjb then @EJB may be used to inject classes. The optional name or
        beanName parameter may be used either specify unqualified class name or the corresponding name on @Stateless or
        @Singleton</p>
    <pre class="brush: java; title: ; notranslate" title="">
@RunWith(CdiRunner.class)
@AdditionalClasses({EJBByClass.class, EJBStatelessNamed.class})
@SupportEjb
class TestEjb {

    @EJB
    EJBI inject;

    @EJB(beanName = &quot;statelessNamed&quot;)
    EJBI injectNamed;

    @EJB(beanName = &quot;EJBByClass&quot;)
    EJBI injectStateless;
  }
}

class EJB implements EJBI {
}

class EJBByClass implements EJBI {
}

@Stateless(name = &quot;statelessNamed&quot;)
class EJBStatelessNamed implements EJBI {
}
</pre>
    <h3 id="deltaspike">11. Deltaspike support</h3>
    <p>Once a test class is annotated with @SupportDeltaspikeCore @SupportDeltaspikeData @SupportDeltaspikeJpa
        @SupportDeltaspikePartialBean then the corresponding deltaspike module can be used. The deltaspike modules must
        be on the classpath.</p>
    <pre class="brush: java; title: ; notranslate" title="">
@SupportDeltaspikeJpa
@SupportDeltaspikeData
@RunWith(CdiRunner.class)
class TestDeltaspikeTransactions {

  @Inject
  TestEntityRepository er;
  EntityManagerFactory emf;

  @PostConstruct
  void init() {
    emf = Persistence.createEntityManagerFactory(&quot;DefaultPersistenceUnit&quot;);
  }

  @Produces
  @RequestScoped
  EntityManager createEntityManager() {
    return emf.createEntityManager();
  }

  @InRequestScope
  @Transactional
  @Test
  public void test() {
    TestEntity t = new TestEntity();
    er.save(t);
  }
}
</pre>
    <h3 id="jaxRs">12. JaxRs support</h3>
    <p>Once a test class is annotated with @SupportJaxRs then many JaxRs classes are available for injection. This means
        that you can inject your web service classes and call the methods directly.</p>
    <p>This will not start up an in memory web server, as this approach always seems to have corner cases that don&#8217;t
        work as expected. Instead verify the functionality of your web services using standard Java method calls.</p>
    <p>The following example web service will be injected with CDI-Unit</p>
    <pre class="brush: java; title: ; notranslate" title="">
@RunWith(CdiRunner.class)
@SupportJaxRs
class TestJaxRs {

  @Inject
  WebService webService;

  //Here goes your tests to call methods on your web service and verify the results.
}


public static class ExampleWebService {
  @Context
  HttpServletRequest request;

  @Context
  HttpServletResponse response;

  @Context
  ServletContext context;

  @Context
  UriInfo uriInfo;

  @Context
  Request jaxRsRequest;

  @Context
  SecurityContext securityContext;

  @Context
  Providers providers;

  @Context
  HttpHeaders headers;

}
</pre>
    <footer class="entry-meta">
    </footer><!-- .entry-meta -->
</div><!-- #main -->
